"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
const axios_1 = __importDefault(require("axios"));
const child_process_1 = require("child_process");
const chokidar = __importStar(require("chokidar"));
const clc = __importStar(require("colorette"));
const fs = __importStar(require("fs"));
const get_port_1 = __importStar(require("get-port"));
const path = __importStar(require("path"));
const terminate_1 = __importDefault(require("terminate"));
const config_1 = require("../plugin/config");
const action_1 = require("../types/action");
const apis = __importStar(require("../types/apis"));
const logger_1 = require("../utils/logger");
const utils_1 = require("../utils/utils");
const types_1 = require("./types");
const EXCLUDED_WATCHER_DIRS = ['node_modules'];
const RELOAD_DELAY_MS = 500;
const STREAM_DELIMITER = '\n';
const DEFAULT_REFLECTION_PORT = 3100;
class Runner {
    directory;
    autoReload;
    buildOnStart;
    appProcess = null;
    watcher = null;
    changeTimeout = null;
    buildCommand;
    reflectionApiPort = DEFAULT_REFLECTION_PORT;
    reflectionApiUrl = () => `http://localhost:${this.reflectionApiPort}/api`;
    constructor(options = {}) {
        this.directory = options.directory || process.cwd();
        this.autoReload = options.autoReload ?? true;
        this.buildOnStart = !!options.buildOnStart;
    }
    async start() {
        if (this.appProcess) {
            logger_1.logger.info('Runner is already running.');
            return Promise.resolve(true);
        }
        if (this.autoReload || this.buildOnStart) {
            const config = await (0, config_1.findToolsConfig)();
            if (config?.runner?.mode !== 'harness') {
                this.buildCommand = config?.builder?.cmd;
                if (!this.buildCommand && (0, utils_1.detectRuntime)(process.cwd()) === 'nodejs') {
                    this.buildCommand = 'npm run build';
                }
                this.build();
            }
        }
        if (this.autoReload) {
            this.watchForChanges();
        }
        return this.startApp();
    }
    async attach(attachAddress) {
        this.reflectionApiPort = parseInt(new URL(attachAddress).port, 10) || 80;
        if (!(await this.healthCheck())) {
            throw new Error(`Unable to attach to provided external dev process address: ${attachAddress}`);
        }
    }
    async stop() {
        if (this.autoReload) {
            await this.watcher?.close();
        }
        await this.stopApp();
    }
    async reloadApp() {
        logger_1.logger.info('Reloading app code.');
        if (this.appProcess) {
            await this.stopApp();
        }
        await this.startApp();
    }
    async startApp() {
        const config = await (0, config_1.findToolsConfig)();
        const runtime = (0, utils_1.detectRuntime)(process.cwd());
        let command = '';
        let args = [];
        switch (runtime) {
            case 'nodejs':
                if (config?.runner?.mode === 'harness') {
                    const localLinkedTsPath = path.join(__dirname, '../../../node_modules/.bin/tsx');
                    const globallyInstalledTsxPath = path.join(__dirname, '../../../../../.bin/tsx');
                    if (fs.existsSync(localLinkedTsPath)) {
                        command = localLinkedTsPath;
                    }
                    else if (globallyInstalledTsxPath) {
                        command = globallyInstalledTsxPath;
                    }
                    else {
                        throw Error('Could not find tsx binary whilst running with harness.');
                    }
                }
                else {
                    command = 'node';
                }
                break;
            case 'go':
                command = 'go';
                args.push('run');
                break;
            default:
                throw Error(`Unexpected runtime while starting app code: ${runtime}`);
        }
        const harnessEntryPoint = path.join(__dirname, '../runner/harness.js');
        const entryPoint = config?.runner?.mode === 'harness'
            ? harnessEntryPoint
            : (0, utils_1.getEntryPoint)(process.cwd());
        if (!entryPoint) {
            logger_1.logger.error('Could not detect entry point for app. Make sure you are at the root of your project directory.');
            return false;
        }
        if (!fs.existsSync(entryPoint)) {
            logger_1.logger.error(`Could not find \`${entryPoint}\`. App not started.`);
            return false;
        }
        const files = config?.runner?.files;
        if (config?.runner?.mode === 'harness') {
            logger_1.logger.info(`Running harness with file paths:\n - ${files?.join('\n - ') || ' - None'}`);
        }
        else {
            logger_1.logger.info(`Starting app at \`${entryPoint}\`...`);
        }
        let port = await (0, get_port_1.default)({ port: this.reflectionApiPort });
        if (port !== this.reflectionApiPort) {
            port = await (0, get_port_1.default)({
                port: (0, get_port_1.makeRange)(DEFAULT_REFLECTION_PORT, DEFAULT_REFLECTION_PORT + 100),
            });
            logger_1.logger.warn(`Port ${this.reflectionApiPort} not available, using ${port} instead.`);
        }
        this.reflectionApiPort = port;
        args.push(entryPoint);
        if (config?.runner?.mode === 'harness' && files) {
            args.push(files.join(','));
        }
        this.appProcess = (0, child_process_1.spawn)(command, args, {
            stdio: 'inherit',
            env: {
                ...process.env,
                GENKIT_ENV: 'dev',
                GENKIT_REFLECTION_PORT: `${this.reflectionApiPort}`,
            },
        });
        this.appProcess.on('error', (error) => {
            logger_1.logger.error(`Error in app process: ${error.message}`);
        });
        this.appProcess.on('exit', (code, signal) => {
            logger_1.logger.info(`App process exited with code ${code}, signal ${signal}`);
            this.appProcess = null;
        });
        return true;
    }
    async stopApp() {
        return new Promise((resolve) => {
            if (this.appProcess) {
                this.appProcess.on('exit', () => {
                    this.appProcess = null;
                    resolve();
                });
                (0, terminate_1.default)(this.appProcess.pid, 'SIGTERM');
            }
            else {
                resolve();
            }
        });
    }
    watchForChanges() {
        this.watcher = chokidar
            .watch(this.directory, {
            persistent: true,
            ignoreInitial: true,
            ignored: (filePath) => {
                return EXCLUDED_WATCHER_DIRS.some((dir) => filePath.includes(path.normalize(dir)));
            },
        })
            .on('add', this.handleFileChange.bind(this))
            .on('change', this.handleFileChange.bind(this));
    }
    handleFileChange(filePath) {
        const extension = path.extname(filePath);
        const relativeFilePath = path.relative(this.directory, filePath);
        if (extension === '.ts' && this.buildCommand) {
            logger_1.logger.info(`Detected a change in ${clc.bold(relativeFilePath)}. Compiling...`);
            try {
                this.build();
            }
            catch (error) {
                logger_1.logger.error('Compilation error:', error);
            }
        }
        else if (extension === '.js' ||
            extension === '.ts' ||
            extension === '.prompt' ||
            extension === '.go') {
            logger_1.logger.info(`Detected a change in ${clc.bold(relativeFilePath)}. Waiting for other changes before reloading.`);
            if (this.changeTimeout) {
                clearTimeout(this.changeTimeout);
            }
            this.changeTimeout = setTimeout(() => {
                void this.reloadApp();
                this.changeTimeout = null;
            }, RELOAD_DELAY_MS);
        }
    }
    build() {
        if (this.buildCommand) {
            (0, child_process_1.execSync)(this.buildCommand, { stdio: 'inherit' });
        }
    }
    httpErrorHandler(error, message) {
        const newError = new types_1.GenkitToolsError(message || 'Internal Error');
        if (error.response) {
            if ((error.response?.data).message) {
                newError.message = (error.response?.data).message;
            }
            newError.data = error.response.data;
            throw newError;
        }
        throw new types_1.GenkitToolsError(message || 'Internal Error', {
            cause: error.cause,
        });
    }
    async healthCheck() {
        try {
            const response = await axios_1.default.get(`${this.reflectionApiUrl()}/__health`);
            if (response.status !== 200) {
                return false;
            }
            return true;
        }
        catch (error) {
            if (error.code === 'ECONNREFUSED') {
                return false;
            }
            throw new Error('Code failed to load, please check log messages above.');
        }
    }
    async sendQuit() {
        try {
            const response = await axios_1.default.get(`${this.reflectionApiUrl()}/__quitquitquit`);
            if (response.status !== 200) {
                return false;
            }
            return true;
        }
        catch (error) {
            if (error.code === 'ECONNREFUSED') {
                return false;
            }
            logger_1.logger.debug('Failed to send quit call.');
            return false;
        }
    }
    async waitUntilHealthy() {
        logger_1.logger.debug(`Checking health of ${this.reflectionApiUrl()}...`);
        for (let i = 0; i < 200; i++) {
            const healthy = await this.healthCheck();
            if (healthy) {
                logger_1.logger.debug('Confirmed healthy.');
                return;
            }
            await new Promise((r) => setTimeout(r, 300));
        }
        throw new Error('Timed out while waiting for code to load.');
    }
    async listActions() {
        const response = await axios_1.default
            .get(`${this.reflectionApiUrl()}/actions`)
            .catch((err) => this.httpErrorHandler(err, 'Error listing actions.'));
        return response.data;
    }
    async runAction(input, streamingCallback) {
        if (streamingCallback) {
            const response = await axios_1.default
                .post(`${this.reflectionApiUrl()}/runAction?stream=true`, input, {
                headers: {
                    'Content-Type': 'application/json',
                },
                responseType: 'stream',
            })
                .catch(this.httpErrorHandler);
            const stream = response.data;
            let buffer = '';
            stream.on('data', (data) => {
                buffer += data;
                while (buffer.includes(STREAM_DELIMITER)) {
                    try {
                        streamingCallback(JSON.parse(buffer.substring(0, buffer.indexOf(STREAM_DELIMITER))));
                        buffer = buffer.substring(buffer.indexOf(STREAM_DELIMITER) + STREAM_DELIMITER.length);
                    }
                    catch (err) {
                        logger_1.logger.error(`Bad stream: ${err}`);
                        break;
                    }
                }
            });
            let resolver;
            let rejecter;
            const promise = new Promise((resolve, reject) => {
                resolver = resolve;
                rejecter = reject;
            });
            stream.on('end', () => {
                resolver(action_1.RunActionResponseSchema.parse(JSON.parse(buffer)));
            });
            stream.on('error', (err) => {
                rejecter(err);
            });
            return promise;
        }
        else {
            const response = await axios_1.default
                .post(`${this.reflectionApiUrl()}/runAction`, input, {
                headers: {
                    'Content-Type': 'application/json',
                },
            })
                .catch((err) => this.httpErrorHandler(err, `Error running action key='${input.key}'.`));
            return action_1.RunActionResponseSchema.parse(response.data);
        }
    }
    async listTraces(input) {
        const { env, limit, continuationToken } = input;
        let query = '';
        if (limit) {
            query += `limit=${limit}`;
        }
        if (continuationToken) {
            if (query !== '') {
                query += '&';
            }
            query += `continuationToken=${continuationToken}`;
        }
        const response = await axios_1.default
            .get(`${this.reflectionApiUrl()}/envs/${env}/traces?${query}`)
            .catch((err) => this.httpErrorHandler(err, `Error listing traces for env='${env}', query='${query}'.`));
        return apis.ListTracesResponseSchema.parse(response.data);
    }
    async getTrace(input) {
        const { env, traceId } = input;
        const response = await axios_1.default
            .get(`${this.reflectionApiUrl()}/envs/${env}/traces/${traceId}`)
            .catch((err) => this.httpErrorHandler(err, `Error getting trace for traceId='${traceId}', env='${env}'.`));
        return response.data;
    }
    async listFlowStates(input) {
        const { env, limit, continuationToken } = input;
        let query = '';
        if (limit) {
            query += `limit=${limit}`;
        }
        if (continuationToken) {
            if (query !== '') {
                query += '&';
            }
            query += `continuationToken=${continuationToken}`;
        }
        const response = await axios_1.default
            .get(`${this.reflectionApiUrl()}/envs/${env}/flowStates?${query}`)
            .catch((err) => this.httpErrorHandler(err, `Error listing flowStates for env='${env}', query='${query}'.`));
        return apis.ListFlowStatesResponseSchema.parse(response.data);
    }
    async getFlowState(input) {
        const { env, flowId } = input;
        const response = await axios_1.default
            .get(`${this.reflectionApiUrl()}/envs/${env}/flowStates/${flowId}`)
            .catch((err) => this.httpErrorHandler(err, `Error getting flowState for flowId='${flowId}', env='${env}'.`));
        return response.data;
    }
}
exports.Runner = Runner;
//# sourceMappingURL=runner.js.map