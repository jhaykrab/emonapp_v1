import { Runner } from '../runner/runner';
import { logger } from './logger';
export async function startRunner() {
    const runner = new Runner({ autoReload: false, buildOnStart: true });
    if (!(await runner.start())) {
        throw new Error('Failed to load app code.');
    }
    await runner.waitUntilHealthy();
    return runner;
}
export async function runInRunnerThenStop(fn) {
    let runner;
    try {
        runner = await startRunner();
    }
    catch (e) {
        process.exit(1);
    }
    try {
        await fn(runner);
    }
    catch (err) {
        logger.info('Command exited with an Error:');
        const error = err;
        if (typeof error.data === 'object') {
            const errorStatus = error.data;
            const { code, details, message } = errorStatus;
            logger.info(`\tCode: ${code}`);
            logger.info(`\tMessage: ${message}`);
            logger.info(`\tTrace: http://localhost:4200/traces/${details.traceId}\n`);
        }
        else {
            logger.info(`\tMessage: ${error.data}\n`);
        }
        logger.error('Stacktrace:');
        logger.error(`${error.stack}`);
    }
    finally {
        await runner.sendQuit();
        await runner.stop();
    }
}
export async function waitForFlowToComplete(runner, flowName, flowId) {
    let state;
    while (true) {
        state = await getFlowState(runner, flowName, flowId);
        if (state.operation.done) {
            break;
        }
        await new Promise((r) => setTimeout(r, 1000));
    }
    return state;
}
export async function getFlowState(runner, flowName, flowId) {
    return (await runner.runAction({
        key: `/flow/${flowName}`,
        input: {
            state: {
                flowId,
            },
        },
    })).result;
}
//# sourceMappingURL=runner-utils.js.map