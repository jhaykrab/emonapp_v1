import { extendZodWithOpenApi } from '@asteasolutions/zod-to-openapi';
import * as z from 'zod';
extendZodWithOpenApi(z);
export const FlowInvokeEnvelopeMessageSchema = z.object({
    start: z
        .object({
        input: z.unknown().optional(),
        labels: z.record(z.string(), z.string()).optional(),
    })
        .optional(),
    schedule: z
        .object({
        input: z.unknown().optional(),
        delay: z.number().optional(),
    })
        .optional(),
    runScheduled: z
        .object({
        flowId: z.string(),
    })
        .optional(),
    retry: z
        .object({
        flowId: z.string(),
    })
        .optional(),
    resume: z
        .object({
        flowId: z.string(),
        payload: z.unknown().optional(),
    })
        .optional(),
    state: z
        .object({
        flowId: z.string(),
    })
        .optional(),
});
export const FlowStateExecutionSchema = z.object({
    startTime: z
        .number()
        .optional()
        .describe('start time in milliseconds since the epoch'),
    endTime: z
        .number()
        .optional()
        .describe('end time in milliseconds since the epoch'),
    traceIds: z.array(z.string()),
});
export const FlowResponseSchema = z.object({
    response: z.unknown().nullable(),
});
export const FlowErrorSchema = z.object({
    error: z.string().optional(),
    stacktrace: z.string().optional(),
});
export const FlowResultSchema = FlowResponseSchema.and(FlowErrorSchema);
export const OperationSchema = z.object({
    name: z
        .string()
        .describe('server-assigned name, which is only unique within the same service that originally ' +
        'returns it.'),
    metadata: z
        .unknown()
        .optional()
        .describe('Service-specific metadata associated with the operation. It typically contains progress ' +
        'information and common metadata such as create time.'),
    done: z
        .boolean()
        .optional()
        .default(false)
        .describe('If the value is false, it means the operation is still in progress. If true, the ' +
        'operation is completed, and either error or response is available.'),
    result: FlowResultSchema.optional(),
    blockedOnStep: z
        .object({
        name: z.string(),
        schema: z.string().optional(),
    })
        .optional(),
});
export const FlowStateSchema = z
    .object({
    name: z.string().optional(),
    flowId: z.string(),
    input: z.unknown(),
    startTime: z
        .number()
        .describe('start time in milliseconds since the epoch'),
    cache: z.record(z.string(), z.object({
        value: z.unknown().optional(),
        empty: z.literal(true).optional(),
    })),
    eventsTriggered: z.record(z.string(), z.unknown()),
    blockedOnStep: z
        .object({
        name: z.string(),
        schema: z.string().optional(),
    })
        .nullable(),
    operation: OperationSchema,
    traceContext: z.string().optional(),
    executions: z.array(FlowStateExecutionSchema),
})
    .openapi('FlowState');
//# sourceMappingURL=flow.js.map