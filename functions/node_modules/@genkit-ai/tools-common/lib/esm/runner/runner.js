import axios from 'axios';
import { execSync, spawn } from 'child_process';
import * as chokidar from 'chokidar';
import * as clc from 'colorette';
import * as fs from 'fs';
import getPort, { makeRange } from 'get-port';
import * as path from 'path';
import terminate from 'terminate';
import { findToolsConfig } from '../plugin/config';
import { RunActionResponseSchema, } from '../types/action';
import * as apis from '../types/apis';
import { logger } from '../utils/logger';
import { detectRuntime, getEntryPoint } from '../utils/utils';
import { GenkitToolsError } from './types';
const EXCLUDED_WATCHER_DIRS = ['node_modules'];
const RELOAD_DELAY_MS = 500;
const STREAM_DELIMITER = '\n';
const DEFAULT_REFLECTION_PORT = 3100;
export class Runner {
    directory;
    autoReload;
    buildOnStart;
    appProcess = null;
    watcher = null;
    changeTimeout = null;
    buildCommand;
    reflectionApiPort = DEFAULT_REFLECTION_PORT;
    reflectionApiUrl = () => `http://localhost:${this.reflectionApiPort}/api`;
    constructor(options = {}) {
        this.directory = options.directory || process.cwd();
        this.autoReload = options.autoReload ?? true;
        this.buildOnStart = !!options.buildOnStart;
    }
    async start() {
        if (this.appProcess) {
            logger.info('Runner is already running.');
            return Promise.resolve(true);
        }
        if (this.autoReload || this.buildOnStart) {
            const config = await findToolsConfig();
            if (config?.runner?.mode !== 'harness') {
                this.buildCommand = config?.builder?.cmd;
                if (!this.buildCommand && detectRuntime(process.cwd()) === 'nodejs') {
                    this.buildCommand = 'npm run build';
                }
                this.build();
            }
        }
        if (this.autoReload) {
            this.watchForChanges();
        }
        return this.startApp();
    }
    async attach(attachAddress) {
        this.reflectionApiPort = parseInt(new URL(attachAddress).port, 10) || 80;
        if (!(await this.healthCheck())) {
            throw new Error(`Unable to attach to provided external dev process address: ${attachAddress}`);
        }
    }
    async stop() {
        if (this.autoReload) {
            await this.watcher?.close();
        }
        await this.stopApp();
    }
    async reloadApp() {
        logger.info('Reloading app code.');
        if (this.appProcess) {
            await this.stopApp();
        }
        await this.startApp();
    }
    async startApp() {
        const config = await findToolsConfig();
        const runtime = detectRuntime(process.cwd());
        let command = '';
        let args = [];
        switch (runtime) {
            case 'nodejs':
                if (config?.runner?.mode === 'harness') {
                    const localLinkedTsPath = path.join(__dirname, '../../../node_modules/.bin/tsx');
                    const globallyInstalledTsxPath = path.join(__dirname, '../../../../../.bin/tsx');
                    if (fs.existsSync(localLinkedTsPath)) {
                        command = localLinkedTsPath;
                    }
                    else if (globallyInstalledTsxPath) {
                        command = globallyInstalledTsxPath;
                    }
                    else {
                        throw Error('Could not find tsx binary whilst running with harness.');
                    }
                }
                else {
                    command = 'node';
                }
                break;
            case 'go':
                command = 'go';
                args.push('run');
                break;
            default:
                throw Error(`Unexpected runtime while starting app code: ${runtime}`);
        }
        const harnessEntryPoint = path.join(__dirname, '../runner/harness.js');
        const entryPoint = config?.runner?.mode === 'harness'
            ? harnessEntryPoint
            : getEntryPoint(process.cwd());
        if (!entryPoint) {
            logger.error('Could not detect entry point for app. Make sure you are at the root of your project directory.');
            return false;
        }
        if (!fs.existsSync(entryPoint)) {
            logger.error(`Could not find \`${entryPoint}\`. App not started.`);
            return false;
        }
        const files = config?.runner?.files;
        if (config?.runner?.mode === 'harness') {
            logger.info(`Running harness with file paths:\n - ${files?.join('\n - ') || ' - None'}`);
        }
        else {
            logger.info(`Starting app at \`${entryPoint}\`...`);
        }
        let port = await getPort({ port: this.reflectionApiPort });
        if (port !== this.reflectionApiPort) {
            port = await getPort({
                port: makeRange(DEFAULT_REFLECTION_PORT, DEFAULT_REFLECTION_PORT + 100),
            });
            logger.warn(`Port ${this.reflectionApiPort} not available, using ${port} instead.`);
        }
        this.reflectionApiPort = port;
        args.push(entryPoint);
        if (config?.runner?.mode === 'harness' && files) {
            args.push(files.join(','));
        }
        this.appProcess = spawn(command, args, {
            stdio: 'inherit',
            env: {
                ...process.env,
                GENKIT_ENV: 'dev',
                GENKIT_REFLECTION_PORT: `${this.reflectionApiPort}`,
            },
        });
        this.appProcess.on('error', (error) => {
            logger.error(`Error in app process: ${error.message}`);
        });
        this.appProcess.on('exit', (code, signal) => {
            logger.info(`App process exited with code ${code}, signal ${signal}`);
            this.appProcess = null;
        });
        return true;
    }
    async stopApp() {
        return new Promise((resolve) => {
            if (this.appProcess) {
                this.appProcess.on('exit', () => {
                    this.appProcess = null;
                    resolve();
                });
                terminate(this.appProcess.pid, 'SIGTERM');
            }
            else {
                resolve();
            }
        });
    }
    watchForChanges() {
        this.watcher = chokidar
            .watch(this.directory, {
            persistent: true,
            ignoreInitial: true,
            ignored: (filePath) => {
                return EXCLUDED_WATCHER_DIRS.some((dir) => filePath.includes(path.normalize(dir)));
            },
        })
            .on('add', this.handleFileChange.bind(this))
            .on('change', this.handleFileChange.bind(this));
    }
    handleFileChange(filePath) {
        const extension = path.extname(filePath);
        const relativeFilePath = path.relative(this.directory, filePath);
        if (extension === '.ts' && this.buildCommand) {
            logger.info(`Detected a change in ${clc.bold(relativeFilePath)}. Compiling...`);
            try {
                this.build();
            }
            catch (error) {
                logger.error('Compilation error:', error);
            }
        }
        else if (extension === '.js' ||
            extension === '.ts' ||
            extension === '.prompt' ||
            extension === '.go') {
            logger.info(`Detected a change in ${clc.bold(relativeFilePath)}. Waiting for other changes before reloading.`);
            if (this.changeTimeout) {
                clearTimeout(this.changeTimeout);
            }
            this.changeTimeout = setTimeout(() => {
                void this.reloadApp();
                this.changeTimeout = null;
            }, RELOAD_DELAY_MS);
        }
    }
    build() {
        if (this.buildCommand) {
            execSync(this.buildCommand, { stdio: 'inherit' });
        }
    }
    httpErrorHandler(error, message) {
        const newError = new GenkitToolsError(message || 'Internal Error');
        if (error.response) {
            if ((error.response?.data).message) {
                newError.message = (error.response?.data).message;
            }
            newError.data = error.response.data;
            throw newError;
        }
        throw new GenkitToolsError(message || 'Internal Error', {
            cause: error.cause,
        });
    }
    async healthCheck() {
        try {
            const response = await axios.get(`${this.reflectionApiUrl()}/__health`);
            if (response.status !== 200) {
                return false;
            }
            return true;
        }
        catch (error) {
            if (error.code === 'ECONNREFUSED') {
                return false;
            }
            throw new Error('Code failed to load, please check log messages above.');
        }
    }
    async sendQuit() {
        try {
            const response = await axios.get(`${this.reflectionApiUrl()}/__quitquitquit`);
            if (response.status !== 200) {
                return false;
            }
            return true;
        }
        catch (error) {
            if (error.code === 'ECONNREFUSED') {
                return false;
            }
            logger.debug('Failed to send quit call.');
            return false;
        }
    }
    async waitUntilHealthy() {
        logger.debug(`Checking health of ${this.reflectionApiUrl()}...`);
        for (let i = 0; i < 200; i++) {
            const healthy = await this.healthCheck();
            if (healthy) {
                logger.debug('Confirmed healthy.');
                return;
            }
            await new Promise((r) => setTimeout(r, 300));
        }
        throw new Error('Timed out while waiting for code to load.');
    }
    async listActions() {
        const response = await axios
            .get(`${this.reflectionApiUrl()}/actions`)
            .catch((err) => this.httpErrorHandler(err, 'Error listing actions.'));
        return response.data;
    }
    async runAction(input, streamingCallback) {
        if (streamingCallback) {
            const response = await axios
                .post(`${this.reflectionApiUrl()}/runAction?stream=true`, input, {
                headers: {
                    'Content-Type': 'application/json',
                },
                responseType: 'stream',
            })
                .catch(this.httpErrorHandler);
            const stream = response.data;
            let buffer = '';
            stream.on('data', (data) => {
                buffer += data;
                while (buffer.includes(STREAM_DELIMITER)) {
                    try {
                        streamingCallback(JSON.parse(buffer.substring(0, buffer.indexOf(STREAM_DELIMITER))));
                        buffer = buffer.substring(buffer.indexOf(STREAM_DELIMITER) + STREAM_DELIMITER.length);
                    }
                    catch (err) {
                        logger.error(`Bad stream: ${err}`);
                        break;
                    }
                }
            });
            let resolver;
            let rejecter;
            const promise = new Promise((resolve, reject) => {
                resolver = resolve;
                rejecter = reject;
            });
            stream.on('end', () => {
                resolver(RunActionResponseSchema.parse(JSON.parse(buffer)));
            });
            stream.on('error', (err) => {
                rejecter(err);
            });
            return promise;
        }
        else {
            const response = await axios
                .post(`${this.reflectionApiUrl()}/runAction`, input, {
                headers: {
                    'Content-Type': 'application/json',
                },
            })
                .catch((err) => this.httpErrorHandler(err, `Error running action key='${input.key}'.`));
            return RunActionResponseSchema.parse(response.data);
        }
    }
    async listTraces(input) {
        const { env, limit, continuationToken } = input;
        let query = '';
        if (limit) {
            query += `limit=${limit}`;
        }
        if (continuationToken) {
            if (query !== '') {
                query += '&';
            }
            query += `continuationToken=${continuationToken}`;
        }
        const response = await axios
            .get(`${this.reflectionApiUrl()}/envs/${env}/traces?${query}`)
            .catch((err) => this.httpErrorHandler(err, `Error listing traces for env='${env}', query='${query}'.`));
        return apis.ListTracesResponseSchema.parse(response.data);
    }
    async getTrace(input) {
        const { env, traceId } = input;
        const response = await axios
            .get(`${this.reflectionApiUrl()}/envs/${env}/traces/${traceId}`)
            .catch((err) => this.httpErrorHandler(err, `Error getting trace for traceId='${traceId}', env='${env}'.`));
        return response.data;
    }
    async listFlowStates(input) {
        const { env, limit, continuationToken } = input;
        let query = '';
        if (limit) {
            query += `limit=${limit}`;
        }
        if (continuationToken) {
            if (query !== '') {
                query += '&';
            }
            query += `continuationToken=${continuationToken}`;
        }
        const response = await axios
            .get(`${this.reflectionApiUrl()}/envs/${env}/flowStates?${query}`)
            .catch((err) => this.httpErrorHandler(err, `Error listing flowStates for env='${env}', query='${query}'.`));
        return apis.ListFlowStatesResponseSchema.parse(response.data);
    }
    async getFlowState(input) {
        const { env, flowId } = input;
        const response = await axios
            .get(`${this.reflectionApiUrl()}/envs/${env}/flowStates/${flowId}`)
            .catch((err) => this.httpErrorHandler(err, `Error getting flowState for flowId='${flowId}', env='${env}'.`));
        return response.data;
    }
}
//# sourceMappingURL=runner.js.map