import { z } from 'zod';
import { ListEvalKeysRequest, ListEvalKeysResponse } from './apis';
export declare const EvalFlowStructuredInputSchema: z.ZodObject<{
    samples: z.ZodArray<z.ZodObject<{
        input: z.ZodAny;
        reference: z.ZodOptional<z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        input?: any;
        reference?: any;
    }, {
        input?: any;
        reference?: any;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    samples: {
        input?: any;
        reference?: any;
    }[];
}, {
    samples: {
        input?: any;
        reference?: any;
    }[];
}>;
export type EvalFlowStructuredInput = z.infer<typeof EvalFlowStructuredInputSchema>;
export declare const EvalFlowInputSchema: z.ZodUnion<[z.ZodArray<z.ZodAny, "many">, z.ZodObject<{
    samples: z.ZodArray<z.ZodObject<{
        input: z.ZodAny;
        reference: z.ZodOptional<z.ZodAny>;
    }, "strip", z.ZodTypeAny, {
        input?: any;
        reference?: any;
    }, {
        input?: any;
        reference?: any;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    samples: {
        input?: any;
        reference?: any;
    }[];
}, {
    samples: {
        input?: any;
        reference?: any;
    }[];
}>]>;
export type EvalFlowInput = z.infer<typeof EvalFlowInputSchema>;
export declare const EvalInputSchema: z.ZodObject<{
    testCaseId: z.ZodString;
    input: z.ZodAny;
    output: z.ZodAny;
    error: z.ZodOptional<z.ZodString>;
    context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    reference: z.ZodOptional<z.ZodAny>;
    traceIds: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    testCaseId: string;
    traceIds: string[];
    input?: any;
    reference?: any;
    output?: any;
    error?: string | undefined;
    context?: string[] | undefined;
}, {
    testCaseId: string;
    traceIds: string[];
    input?: any;
    reference?: any;
    output?: any;
    error?: string | undefined;
    context?: string[] | undefined;
}>;
export type EvalInput = z.infer<typeof EvalInputSchema>;
export declare const EvalMetricSchema: z.ZodObject<{
    evaluator: z.ZodString;
    score: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString, z.ZodBoolean]>>;
    rationale: z.ZodOptional<z.ZodString>;
    error: z.ZodOptional<z.ZodString>;
    traceId: z.ZodOptional<z.ZodString>;
    spanId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    evaluator: string;
    traceId?: string | undefined;
    error?: string | undefined;
    score?: string | number | boolean | undefined;
    rationale?: string | undefined;
    spanId?: string | undefined;
}, {
    evaluator: string;
    traceId?: string | undefined;
    error?: string | undefined;
    score?: string | number | boolean | undefined;
    rationale?: string | undefined;
    spanId?: string | undefined;
}>;
export type EvalMetric = z.infer<typeof EvalMetricSchema>;
export declare const EvalResultSchema: z.ZodObject<z.objectUtil.extendShape<{
    testCaseId: z.ZodString;
    input: z.ZodAny;
    output: z.ZodAny;
    error: z.ZodOptional<z.ZodString>;
    context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    reference: z.ZodOptional<z.ZodAny>;
    traceIds: z.ZodArray<z.ZodString, "many">;
}, {
    metrics: z.ZodOptional<z.ZodArray<z.ZodObject<{
        evaluator: z.ZodString;
        score: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString, z.ZodBoolean]>>;
        rationale: z.ZodOptional<z.ZodString>;
        error: z.ZodOptional<z.ZodString>;
        traceId: z.ZodOptional<z.ZodString>;
        spanId: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        evaluator: string;
        traceId?: string | undefined;
        error?: string | undefined;
        score?: string | number | boolean | undefined;
        rationale?: string | undefined;
        spanId?: string | undefined;
    }, {
        evaluator: string;
        traceId?: string | undefined;
        error?: string | undefined;
        score?: string | number | boolean | undefined;
        rationale?: string | undefined;
        spanId?: string | undefined;
    }>, "many">>;
}>, "strip", z.ZodTypeAny, {
    testCaseId: string;
    traceIds: string[];
    input?: any;
    reference?: any;
    output?: any;
    error?: string | undefined;
    context?: string[] | undefined;
    metrics?: {
        evaluator: string;
        traceId?: string | undefined;
        error?: string | undefined;
        score?: string | number | boolean | undefined;
        rationale?: string | undefined;
        spanId?: string | undefined;
    }[] | undefined;
}, {
    testCaseId: string;
    traceIds: string[];
    input?: any;
    reference?: any;
    output?: any;
    error?: string | undefined;
    context?: string[] | undefined;
    metrics?: {
        evaluator: string;
        traceId?: string | undefined;
        error?: string | undefined;
        score?: string | number | boolean | undefined;
        rationale?: string | undefined;
        spanId?: string | undefined;
    }[] | undefined;
}>;
export type EvalResult = z.infer<typeof EvalResultSchema>;
export declare const EvalRunKeySchema: z.ZodObject<{
    actionId: z.ZodOptional<z.ZodString>;
    evalRunId: z.ZodString;
    createdAt: z.ZodString;
}, "strip", z.ZodTypeAny, {
    evalRunId: string;
    createdAt: string;
    actionId?: string | undefined;
}, {
    evalRunId: string;
    createdAt: string;
    actionId?: string | undefined;
}>;
export type EvalRunKey = z.infer<typeof EvalRunKeySchema>;
export declare const EvalRunSchema: z.ZodObject<{
    key: z.ZodObject<{
        actionId: z.ZodOptional<z.ZodString>;
        evalRunId: z.ZodString;
        createdAt: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        evalRunId: string;
        createdAt: string;
        actionId?: string | undefined;
    }, {
        evalRunId: string;
        createdAt: string;
        actionId?: string | undefined;
    }>;
    results: z.ZodArray<z.ZodObject<z.objectUtil.extendShape<{
        testCaseId: z.ZodString;
        input: z.ZodAny;
        output: z.ZodAny;
        error: z.ZodOptional<z.ZodString>;
        context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        reference: z.ZodOptional<z.ZodAny>;
        traceIds: z.ZodArray<z.ZodString, "many">;
    }, {
        metrics: z.ZodOptional<z.ZodArray<z.ZodObject<{
            evaluator: z.ZodString;
            score: z.ZodOptional<z.ZodUnion<[z.ZodNumber, z.ZodString, z.ZodBoolean]>>;
            rationale: z.ZodOptional<z.ZodString>;
            error: z.ZodOptional<z.ZodString>;
            traceId: z.ZodOptional<z.ZodString>;
            spanId: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            evaluator: string;
            traceId?: string | undefined;
            error?: string | undefined;
            score?: string | number | boolean | undefined;
            rationale?: string | undefined;
            spanId?: string | undefined;
        }, {
            evaluator: string;
            traceId?: string | undefined;
            error?: string | undefined;
            score?: string | number | boolean | undefined;
            rationale?: string | undefined;
            spanId?: string | undefined;
        }>, "many">>;
    }>, "strip", z.ZodTypeAny, {
        testCaseId: string;
        traceIds: string[];
        input?: any;
        reference?: any;
        output?: any;
        error?: string | undefined;
        context?: string[] | undefined;
        metrics?: {
            evaluator: string;
            traceId?: string | undefined;
            error?: string | undefined;
            score?: string | number | boolean | undefined;
            rationale?: string | undefined;
            spanId?: string | undefined;
        }[] | undefined;
    }, {
        testCaseId: string;
        traceIds: string[];
        input?: any;
        reference?: any;
        output?: any;
        error?: string | undefined;
        context?: string[] | undefined;
        metrics?: {
            evaluator: string;
            traceId?: string | undefined;
            error?: string | undefined;
            score?: string | number | boolean | undefined;
            rationale?: string | undefined;
            spanId?: string | undefined;
        }[] | undefined;
    }>, "many">;
    metricsMetadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        displayName: z.ZodString;
        definition: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        displayName: string;
        definition: string;
    }, {
        displayName: string;
        definition: string;
    }>>>;
}, "strip", z.ZodTypeAny, {
    key: {
        evalRunId: string;
        createdAt: string;
        actionId?: string | undefined;
    };
    results: {
        testCaseId: string;
        traceIds: string[];
        input?: any;
        reference?: any;
        output?: any;
        error?: string | undefined;
        context?: string[] | undefined;
        metrics?: {
            evaluator: string;
            traceId?: string | undefined;
            error?: string | undefined;
            score?: string | number | boolean | undefined;
            rationale?: string | undefined;
            spanId?: string | undefined;
        }[] | undefined;
    }[];
    metricsMetadata?: Record<string, {
        displayName: string;
        definition: string;
    }> | undefined;
}, {
    key: {
        evalRunId: string;
        createdAt: string;
        actionId?: string | undefined;
    };
    results: {
        testCaseId: string;
        traceIds: string[];
        input?: any;
        reference?: any;
        output?: any;
        error?: string | undefined;
        context?: string[] | undefined;
        metrics?: {
            evaluator: string;
            traceId?: string | undefined;
            error?: string | undefined;
            score?: string | number | boolean | undefined;
            rationale?: string | undefined;
            spanId?: string | undefined;
        }[] | undefined;
    }[];
    metricsMetadata?: Record<string, {
        displayName: string;
        definition: string;
    }> | undefined;
}>;
export type EvalRun = z.infer<typeof EvalRunSchema>;
export interface EvalStore {
    save(evalRun: EvalRun): Promise<void>;
    load(evalRunId: string, actionId?: string): Promise<EvalRun | undefined>;
    list(query?: ListEvalKeysRequest): Promise<ListEvalKeysResponse>;
}
