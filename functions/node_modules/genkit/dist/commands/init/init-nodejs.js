"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promptWriteMode = exports.initNodejs = void 0;
const utils_1 = require("@genkit-ai/tools-common/utils");
const child_process_1 = require("child_process");
const extract_zip_1 = __importDefault(require("extract-zip"));
const fs_1 = __importDefault(require("fs"));
const inquirer = __importStar(require("inquirer"));
const ora_1 = __importDefault(require("ora"));
const path_1 = __importDefault(require("path"));
const util_1 = require("util");
const init_1 = require("../init");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const modelOptions = {
    googleai: { label: 'Google AI', plugin: '@genkit-ai/googleai' },
    vertexai: {
        label: 'Google Cloud Vertex AI',
        plugin: '@genkit-ai/vertexai',
    },
    ollama: { label: 'Ollama (e.g. Gemma)', plugin: 'genkitx-ollama' },
    none: { label: 'None', plugin: undefined },
};
const platformOptions = {
    firebase: { label: 'Firebase', plugin: '@genkit-ai/firebase' },
    other: { label: 'Other platforms', plugin: undefined },
};
const pluginToInfo = {
    '@genkit-ai/firebase': {
        imports: 'firebase',
        init: `
    // Load the Firebase plugin, which provides integrations with several
    // Firebase services.
    firebase()`.trimStart(),
    },
    '@genkit-ai/google-cloud': {
        imports: 'googleCloud',
        init: 'googleCloud()',
    },
    '@genkit-ai/vertexai': {
        imports: 'vertexAI',
        modelImportComment: `
// Import models from the Vertex AI plugin. The Vertex AI API provides access to
// several generative models. Here, we import Gemini 1.5 Flash.`.trimStart(),
        init: `
    // Load the Vertex AI plugin. You can optionally specify your project ID
    // by passing in a config object; if you don't, the Vertex AI plugin uses
    // the value from the GCLOUD_PROJECT environment variable.
    vertexAI({ location: 'us-central1' })`.trimStart(),
        model: 'gemini15Flash',
    },
    'genkitx-ollama': {
        imports: 'ollama',
        init: `
    ollama({
      // Ollama provides an interface to many open generative models. Here,
      // we specify Google's Gemma model. The models you specify must already be
      // downloaded and available to the Ollama server.
      models: [{ name: 'gemma' }],
      // The address of your Ollama API server. This is often a different host
      // from your app backend (which runs Genkit), in order to run Ollama on
      // a GPU-accelerated machine.
      serverAddress: 'http://127.0.0.1:11434',
    })`.trimStart(),
        modelStr: "'ollama/gemma'",
    },
    '@genkit-ai/googleai': {
        imports: 'googleAI',
        modelImportComment: `
// Import models from the Google AI plugin. The Google AI API provides access to
// several generative models. Here, we import Gemini 1.5 Flash.`.trimStart(),
        init: `
    // Load the Google AI plugin. You can optionally specify your API key
    // by passing in a config object; if you don't, the Google AI plugin uses
    // the value from the GOOGLE_GENAI_API_KEY environment variable, which is
    // the recommended practice.
    googleAI()`.trimStart(),
        model: 'gemini15Flash',
    },
};
const sampleTemplatePaths = {
    firebase: '../../../config/firebase.index.ts.template',
    nodejs: '../../../config/nodejs.index.ts.template',
    nextjs: '../../../config/nextjs.genkit.ts.template',
};
const nextjsToolsConfigTemplatePath = '../../../config/nextjs.genkit-tools.config.js.template';
const externalPackages = ['zod', 'express'];
const externalDevPackages = ['typescript'];
const internalPackages = [
    '@genkit-ai/core',
    '@genkit-ai/ai',
    '@genkit-ai/dotprompt',
    '@genkit-ai/flow',
];
const platformImportOptions = {
    firebase: { spacer: '', quotes: '"' },
    other: { spacer: ' ', quotes: "'" },
};
async function initNodejs(options, isNew) {
    let { platform, model, distArchive } = options;
    const supportedPlatforms = Object.keys(platformOptions);
    if (platform && !supportedPlatforms.includes(platform)) {
        throw new Error(`\`${platform}\` is not a supported platform for Node.js. Supported platforms: ${supportedPlatforms}`);
    }
    const supportedModels = Object.keys(modelOptions);
    if (model && !supportedModels.includes(model)) {
        throw new Error(`\`${model}\` is not a supported model provider for Node.js. Supported model providers: ${supportedModels}`);
    }
    platform = platform || 'other';
    let sampleTarget = 'nodejs';
    if (platform === 'firebase') {
        sampleTarget = 'firebase';
    }
    else {
        if (isFirebaseProject() &&
            (await (0, init_1.confirm)({
                message: 'Detected a Firebase project. Would you like to configure Genkit for Firebase?',
                default: true,
            }))) {
            sampleTarget = 'firebase';
        }
        else if (isNextJsProject() &&
            (await (0, init_1.confirm)({
                message: 'Detected a Next.js project. Would you like to configure Genkit for Next.js?',
                default: true,
            }))) {
            sampleTarget = 'nextjs';
        }
    }
    if (!model) {
        const answer = await inquirer.prompt([
            {
                type: 'list',
                name: 'model',
                message: 'Select a model provider:',
                choices: supportedModels.map((model) => ({
                    name: modelOptions[model].label,
                    value: model,
                })),
            },
        ]);
        model = answer.model;
    }
    const plugins = [];
    if (platformOptions[platform]?.plugin) {
        plugins.push(platformOptions[platform].plugin);
    }
    if (modelOptions[model]?.plugin) {
        plugins.push(modelOptions[model].plugin);
    }
    const packages = [...externalPackages];
    if (!distArchive) {
        packages.push(...internalPackages);
        packages.push(...plugins);
    }
    if (isNew) {
        const spinner = (0, ora_1.default)('Initializing NPM project').start();
        try {
            await execAsync('npm init -y');
            spinner.succeed('Successfully initialized NPM project');
        }
        catch (err) {
            spinner.fail(`Failed to initialize NPM project: ${err}`);
            process.exit(1);
        }
    }
    await installNpmPackages(packages, externalDevPackages, distArchive);
    if (!fs_1.default.existsSync('src')) {
        fs_1.default.mkdirSync('src');
    }
    await updateTsConfig(options.nonInteractive || isNew);
    await updatePackageJson(options.nonInteractive || isNew);
    if (options.nonInteractive ||
        (await (0, init_1.confirm)({
            message: 'Would you like to generate a sample flow?',
            default: true,
        }))) {
        generateSampleFile(platform, sampleTarget, modelOptions[model].plugin, plugins);
    }
    generateToolsConfig(sampleTarget);
    (0, init_1.showModelInfo)(model);
    await (0, utils_1.record)(new utils_1.InitEvent(sampleTarget));
}
exports.initNodejs = initNodejs;
async function updateTsConfig(nonInteractive) {
    const tsConfigPath = path_1.default.join(process.cwd(), 'tsconfig.json');
    let existingTsConfig = undefined;
    if (fs_1.default.existsSync(tsConfigPath)) {
        existingTsConfig = JSON.parse(fs_1.default.readFileSync(tsConfigPath, 'utf-8'));
    }
    let choice = 'overwrite';
    if (!nonInteractive && existingTsConfig) {
        choice = await promptWriteMode('Would you like to update your tsconfig.json with suggested settings?');
    }
    const tsConfig = {
        compileOnSave: true,
        include: ['src'],
        compilerOptions: {
            module: 'commonjs',
            noImplicitReturns: true,
            outDir: 'lib',
            sourceMap: true,
            strict: true,
            target: 'es2017',
            skipLibCheck: true,
            esModuleInterop: true,
        },
    };
    const spinner = (0, ora_1.default)('Updating tsconfig.json').start();
    let newTsConfig = {};
    switch (choice) {
        case 'overwrite':
            newTsConfig = {
                ...existingTsConfig,
                ...tsConfig,
                compilerOptions: {
                    ...existingTsConfig?.compilerOptions,
                    ...tsConfig.compilerOptions,
                },
            };
            break;
        case 'merge':
            newTsConfig = {
                ...tsConfig,
                ...existingTsConfig,
                compilerOptions: {
                    ...tsConfig.compilerOptions,
                    ...existingTsConfig?.compilerOptions,
                },
            };
            break;
        case 'keep':
            spinner.warn('Skipped updating tsconfig.json');
            return;
    }
    try {
        fs_1.default.writeFileSync(tsConfigPath, JSON.stringify(newTsConfig, null, 2));
        spinner.succeed('Successfully updated tsconfig.json');
    }
    catch (err) {
        spinner.fail(`Failed to update tsconfig.json: ${err}`);
        process.exit(1);
    }
}
async function installNpmPackages(packages, devPackages, distArchive) {
    const spinner = (0, ora_1.default)('Installing NPM packages').start();
    try {
        if (packages.length) {
            await execAsync(`npm install ${packages.join(' ')} --save`);
        }
        if (devPackages?.length) {
            await execAsync(`npm install ${devPackages.join(' ')} --save-dev`);
        }
        if (distArchive) {
            const distDir = 'genkit-dist';
            const outputPath = path_1.default.join(process.cwd(), distDir);
            if (!fs_1.default.existsSync(distDir)) {
                fs_1.default.mkdirSync(distDir);
            }
            await (0, extract_zip_1.default)(distArchive, { dir: outputPath });
            await execAsync(`npm install ${outputPath}/*.tgz --save`);
        }
        spinner.succeed('Successfully installed NPM packages');
    }
    catch (err) {
        spinner.fail(`Failed to install NPM packages: ${err}`);
        process.exit(1);
    }
}
function generateSampleFile(platform, sampleTarget, modelPlugin, configPlugins) {
    const modelImport = modelPlugin && pluginToInfo[modelPlugin].model
        ? '\n' +
            generateImportStatement(pluginToInfo[modelPlugin].model, modelPlugin, platformImportOptions[platform]) +
            '\n'
        : '';
    const modelImportComment = modelPlugin && pluginToInfo[modelPlugin].modelImportComment
        ? `\n${pluginToInfo[modelPlugin].modelImportComment}`
        : '';
    const commentedModelImport = `${modelImportComment}${modelImport}`;
    const templatePath = path_1.default.join(__dirname, sampleTemplatePaths[sampleTarget]);
    let template = fs_1.default.readFileSync(templatePath, 'utf8');
    const sample = renderConfig(configPlugins, platform, template
        .replace('$GENKIT_MODEL_IMPORT\n', commentedModelImport)
        .replace('$GENKIT_MODEL', modelPlugin
        ? pluginToInfo[modelPlugin].model ||
            pluginToInfo[modelPlugin].modelStr ||
            ''
        : "'' /* TODO: Set a model. */"));
    const spinner = (0, ora_1.default)('Generating sample file').start();
    try {
        let samplePath = 'src/index.ts';
        if (sampleTarget === 'nextjs') {
            if (fs_1.default.existsSync('src/app')) {
                samplePath = 'src/app/genkit.ts';
            }
            else if (fs_1.default.existsSync('app')) {
                samplePath = 'app/genkit.ts';
            }
            else {
                throw new Error('Unable to resolve source folder (app or src/app) of you next.js app.');
            }
        }
        fs_1.default.writeFileSync(path_1.default.join(process.cwd(), samplePath), sample, 'utf8');
        spinner.succeed(`Successfully generated sample file (${samplePath})`);
    }
    catch (err) {
        spinner.fail(`Failed to generate sample file: ${err}`);
        process.exit(1);
    }
}
async function updatePackageJson(nonInteractive) {
    const packageJsonPath = path_1.default.join(process.cwd(), 'package.json');
    if (!fs_1.default.existsSync(packageJsonPath)) {
        throw new Error('Failed to find package.json.');
    }
    const existingPackageJson = JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf8'));
    const choice = nonInteractive
        ? 'overwrite'
        : await promptWriteMode('Would you like to update your package.json with suggested settings?');
    const packageJson = {
        main: 'lib/index.js',
        scripts: {
            start: 'node lib/index.js',
            build: 'tsc',
            'build:watch': 'tsc --watch',
        },
    };
    const spinner = (0, ora_1.default)('Updating package.json').start();
    let newPackageJson = {};
    switch (choice) {
        case 'overwrite':
            newPackageJson = {
                ...existingPackageJson,
                ...packageJson,
                scripts: {
                    ...existingPackageJson.scripts,
                    ...packageJson.scripts,
                },
            };
            break;
        case 'merge':
            newPackageJson = {
                ...packageJson,
                ...existingPackageJson,
                main: packageJson.main,
                scripts: {
                    ...packageJson.scripts,
                    ...existingPackageJson.scripts,
                },
            };
            break;
        case 'keep':
            spinner.warn('Skipped updating package.json');
            return;
    }
    try {
        fs_1.default.writeFileSync(packageJsonPath, JSON.stringify(newPackageJson, null, 2));
        spinner.succeed('Successfully updated package.json');
    }
    catch (err) {
        spinner.fail(`Failed to update package.json: ${err}`);
        process.exit(1);
    }
}
function renderConfig(pluginNames, platform, template) {
    const imports = pluginNames
        .map((pluginName) => generateImportStatement(pluginToInfo[pluginName].imports, pluginName, platformImportOptions[platform]))
        .join('\n');
    const plugins = pluginNames
        .map((pluginName) => `    ${pluginToInfo[pluginName].init},`)
        .join('\n') || '    /* Add your plugins here. */';
    return template
        .replace('$GENKIT_CONFIG_IMPORTS', imports)
        .replace('$GENKIT_CONFIG_PLUGINS', plugins);
}
function generateImportStatement(imports, name, opts) {
    return `import {${opts.spacer}${imports}${opts.spacer}} from ${opts.quotes}${name}${opts.quotes};`;
}
function generateToolsConfig(sampleTarget) {
    if (sampleTarget === 'nextjs') {
        const templatePath = path_1.default.join(__dirname, nextjsToolsConfigTemplatePath);
        let template = fs_1.default.readFileSync(templatePath, 'utf8');
        if (fs_1.default.existsSync('src/app')) {
            template = template.replace('$GENKIT_HARNESS_FILES', `'./src/app/*.ts'`);
        }
        else if (fs_1.default.existsSync('app')) {
            template = template.replace('$GENKIT_HARNESS_FILES', `'./app/*.ts'`);
        }
        else {
            throw new Error('Unable to resolve source folder (app or src/app) of you next.js app.');
        }
        const spinner = (0, ora_1.default)('Updating genkit-tools.conf.js').start();
        try {
            fs_1.default.writeFileSync(path_1.default.join(process.cwd(), 'genkit-tools.conf.js'), template, 'utf8');
            spinner.succeed('Successfully updated genkit-tools.conf.js');
        }
        catch (err) {
            spinner.fail(`Failed to update genkit-tools.conf.js: ${err}`);
            process.exit(1);
        }
    }
}
function isNextJsProject(projectDir = process.cwd()) {
    const hasNextConfig = fs_1.default.existsSync(path_1.default.join(projectDir, 'next.config.js'));
    let packageJson;
    try {
        packageJson = JSON.parse(fs_1.default.readFileSync(path_1.default.join(projectDir, 'package.json'), 'utf8'));
    }
    catch (error) {
        return false;
    }
    const hasNextDependency = packageJson.dependencies && packageJson.dependencies.next;
    return hasNextConfig || hasNextDependency;
}
function isFirebaseProject(projectDir = process.cwd()) {
    const filename = 'firebase.json';
    return (fs_1.default.existsSync(path_1.default.join(projectDir, filename)) ||
        fs_1.default.existsSync(path_1.default.join(projectDir, '..', filename)));
}
async function promptWriteMode(message, defaultOption = 'merge') {
    const answers = await inquirer.prompt([
        {
            type: 'list',
            name: 'option',
            message,
            choices: [
                { name: 'Set if unset', value: 'merge' },
                { name: 'Overwrite', value: 'overwrite' },
                { name: 'Keep unchanged', value: 'keep' },
            ],
            default: defaultOption,
        },
    ]);
    return answers.option;
}
exports.promptWriteMode = promptWriteMode;
//# sourceMappingURL=init-nodejs.js.map